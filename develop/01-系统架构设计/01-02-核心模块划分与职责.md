# 核心模块划分与职责

## 1. 基础设施层模块

基础设施层提供与外部系统（CTP、监管系统、网络）的交互能力，为上层服务提供稳定、高效的基础设施支持。

### 1.1 CTP API封装器

**职责描述：**
抽象CTP TraderAPI/MdAPI的底层细节，提供统一的异步接口、错误处理机制和连接管理。封装CTP v6.7.11标准版API，隔离版本差异，为上层提供稳定的交易与行情接入服务。

**核心功能：**
- **统一异步接口：** 将CTP同步/异步混合接口转换为纯异步事件驱动模型
- **错误处理标准化：** 统一错误码映射，提供可读的错误信息和恢复策略
- **连接池管理：** 多连接负载均衡，自动故障切换和重连
- **会话状态维护：** 登录状态、心跳检测、会话恢复
- **穿透式监管集成：** 与datacollectforlinux-v1.2.6无缝集成

**接口定义（C++伪代码）：**
```cpp
class CTPClient {
public:
    // 异步连接管理
    Future<ConnectResult> connectAsync(const ConnectConfig& config);
    Future<void> disconnectAsync();
    
    // 行情订阅（异步）
    Future<SubscribeResult> subscribeMarketData(const vector<string>& instrumentIDs);
    Future<SubscribeResult> unsubscribeMarketData(const vector<string>& instrumentIDs);
    
    // 交易操作（异步）
    Future<OrderResult> placeOrderAsync(const OrderRequest& req);
    Future<OrderResult> cancelOrderAsync(const string& orderRef);
    
    // 查询接口（异步）
    Future<AccountInfo> queryAccountAsync();
    Future<vector<PositionDetail>> queryPositionsAsync();
    Future<vector<InstrumentInfo>> queryInstrumentsAsync();
    
    // 事件回调注册
    void registerMarketDataCallback(MarketDataCallback cb);
    void registerOrderCallback(OrderCallback cb);
    void registerTradeCallback(TradeCallback cb);
    
    // 错误处理
    void registerErrorCallback(ErrorCallback cb);
    ErrorCode getLastError() const;
    string getErrorMessage(ErrorCode code) const;
};

// 统一的错误处理接口
class CTPErrorHandler {
public:
    enum class RecoveryAction {
        RETRY_IMMEDIATE,    // 立即重试
        RETRY_WITH_BACKOFF, // 退避重试
        SWITCH_CONNECTION,  // 切换连接
        REPORT_AND_CONTINUE, // 报告后继续
        REPORT_AND_HALT     // 报告后停止
    };
    
    RecoveryAction analyzeError(ErrorCode code, const ErrorContext& ctx);
    void handleError(ErrorCode code, const ErrorContext& ctx);
};
```

**性能要求：**
- **连接建立时间：** < 500ms（含认证、初始化）
- **行情订阅延迟：** P99 < 100ms（从请求到确认）
- **订单操作延迟：** P99 < 200ms（从请求到CTP确认）
- **查询响应延迟：** P99 < 300ms（资金/持仓查询）
- **心跳检测间隔：** 3秒，超时检测 < 5秒
- **重连恢复时间：** < 10秒（包含会话恢复）

**依赖关系：**
- 直接依赖CTP v6.7.11动态库
- 依赖穿透式监管集成器进行数据采集
- 为行情引擎、订单引擎提供数据接口

### 1.2 穿透式监管集成器

**职责描述：**
封装datacollectforlinux-v1.2.6数据采集组件，实现实时交易数据采集、本地加密存储和监管上报功能。确保系统完全符合中国期货市场穿透式监管要求。

**核心功能：**
- **实时数据采集：** 交易指令、成交回报、持仓变更、资金变动的实时捕获
- **本地加密存储：** AES-256加密存储，防篡改设计，数据完整性校验
- **监管上报：** 通过HTTP/2 + TLS 1.3协议向监管系统上报数据
- **断点续传：** 网络异常时数据缓存，恢复后自动补报
- **完整性验证：** 数据完整性校验，防止数据丢失或篡改

**接口定义：**
```cpp
class RegulatoryCollector {
public:
    // 初始化与配置
    bool initialize(const RegulatoryConfig& config);
    
    // 数据采集接口
    void collectTradeRecord(const TradeRecord& record);
    void collectOrderRecord(const OrderRecord& record);
    void collectPositionChange(const PositionChange& change);
    void collectAccountChange(const AccountChange& change);
    
    // 上报控制
    void startReporting();
    void stopReporting();
    void pauseReporting();
    void resumeReporting();
    
    // 状态查询
    ReportingStatus getReportingStatus() const;
    size_t getPendingRecords() const;
    size_t getTotalReported() const;
    
    // 数据验证
    bool verifyDataIntegrity(const string& date);
    vector<DataIntegrityIssue> auditData(const string& date);
};

// 数据存储接口
class RegulatoryStorage {
public:
    bool storeRecord(const RegulatoryRecord& record);
    vector<RegulatoryRecord> loadRecords(const TimeRange& range);
    bool deleteRecords(const TimeRange& range); // 仅限过期数据
    size_t getStorageUsage() const;
    
    // 加密管理
    void rotateEncryptionKey(const string& newKey);
    bool verifyEncryption() const;
};
```

**性能要求：**
- **采集延迟：** < 10μs（从事件发生到采集完成）
- **存储延迟：** < 100μs（数据写入本地加密存储）
- **上报延迟：** P99 < 1秒（从采集到成功上报）
- **数据完整性：** 100%（无数据丢失）
- **存储容量：** 支持5年数据存储（按监管要求）
- **恢复时间：** 断网后数据恢复上报 < 30秒

**依赖关系：**
- 直接依赖datacollectforlinux-v1.2.6组件
- 依赖CTP API封装器获取原始交易数据
- 为审计和合规检查提供数据源

### 1.3 查询流控与调度器

**职责描述：**
对查询类请求进行速率限制与优先级调度，避免触发外部系统（如 CTP 前置）的流控限制。

**核心功能：**
- **速率限制：** 令牌桶控制 QPS 上限
- **优先级队列：** 高/中/低优先级调度
- **可观测性：** 暴露队列长度、排队时间等指标用于诊断

**接口定义（当前落地）：**
参考 `include/quant_hft/core/query_scheduler.h` 的 `QueryScheduler`。

**依赖关系：**
- 作为 CTP 网关适配层的查询子模块被调用

## 2. 核心服务层模块

核心服务层实现交易系统的核心业务逻辑，包括行情处理、订单管理、风险控制和市场状态识别。

### 2.1 行情引擎

**职责描述：**
处理Tick级行情数据，维护实时订单簿，合成分钟K线，为策略提供高质量的市场数据。

**核心功能：**
- **Tick数据解析：** 解析CTP深度行情，标准化数据结构
- **订单簿维护：** 实时买卖盘口维护，增量更新优化
- **K线合成：** 1分钟/5分钟/15分钟等多周期K线实时合成
- **数据校验：** 价格合理性检查，数据完整性验证
- **数据分发：** 多播模式向订阅者分发行情数据

**接口定义：**
```cpp
class MarketDataEngine {
public:
    // 行情订阅
    SubscriptionHandle subscribe(const string& instrumentID, 
                                DataType dataType, 
                                DataCallback callback);
    void unsubscribe(SubscriptionHandle handle);
    
    // 数据查询
    optional<TickData> getLatestTick(const string& instrumentID) const;
    optional<OrderBook> getOrderBook(const string& instrumentID) const;
    vector<MinuteBar> getRecentBars(const string& instrumentID, 
                                    BarPeriod period, 
                                    size_t count) const;
    
    // 引擎控制
    void start();
    void stop();
    void pause();
    void resume();
    
    // 状态监控
    EngineStats getStats() const;
    size_t getActiveSubscriptions() const;
};

// 订单簿维护器
class OrderBookMaintainer {
public:
    void update(const DepthMarketData& marketData);
    OrderBook getOrderBook() const;
    
    // 高级查询
    double getMidPrice() const;
    double getWeightedMidPrice(size_t levels = 5) const;
    double getOrderBookImbalance() const;
    double getMicroPrice() const;
    
    // 时间序列分析
    vector<OrderBookSnapshot> getHistory(TimeRange range) const;
};
```

**性能要求：**
- **Tick处理延迟：** P99 < 100μs（从接收到处理完成）
- **订单簿更新延迟：** < 10μs（单次更新）
- **K线合成延迟：** < 1ms（分钟结束时完成合成）
- **数据查询延迟：** < 50μs（内存查询）
- **并发处理能力：** > 1000个合约同时处理
- **内存使用：** < 2GB（全市场订单簿维护）

**依赖关系：**
- 依赖CTP API封装器获取原始行情
- 依赖网络通信管理器分发数据
- 为市场状态识别引擎提供原始数据

### 2.2 订单引擎

**职责描述：**
管理订单完整生命周期，处理CTP异步回调，实现智能订单路由和状态同步。

**核心功能：**
- **订单生命周期管理：** 从报单到成交/撤单的完整状态跟踪
- **异步回调处理：** 统一处理CTP订单相关回调（OnRtnOrder、OnRtnTrade等）
- **智能订单路由：** 多账户、多策略的订单路由和资金分配
- **状态同步：** 确保内存状态与CTP服务器状态一致
- **异常处理：** 订单超时、部分成交、拒绝等异常情况处理

**接口定义：**
```cpp
class OrderEngine {
public:
    // 订单操作
    Future<OrderResponse> placeOrder(const OrderRequest& request);
    Future<CancelResponse> cancelOrder(const string& orderID);
    Future<CancelResponse> cancelAllOrders(const string& strategyID);
    
    // 订单查询
    optional<OrderStatus> getOrderStatus(const string& orderID) const;
    vector<OrderStatus> getActiveOrders() const;
    vector<OrderStatus> getStrategyOrders(const string& strategyID) const;
    vector<TradeRecord> getRecentTrades(size_t count = 100) const;
    
    // 引擎控制
    void start();
    void stop();
    void pauseNewOrders();  // 暂停新订单（用于风控）
    void resumeNewOrders();
    
    // 回调注册
    void registerOrderCallback(OrderCallback cb);
    void registerTradeCallback(TradeCallback cb);
    
    // 状态同步
    Future<void> syncWithCTP();  // 主动同步状态
};

// 订单状态机
class OrderStateMachine {
public:
    enum class State {
        PENDING_NEW,    // 待报单
        NEW,           // 已报单
        PARTIALLY_FILLED, // 部分成交
        FILLED,        // 完全成交
        PENDING_CANCEL, // 待撤单
        CANCELLED,     // 已撤单
        REJECTED,      // 已拒绝
        EXPIRED        // 已过期
    };
    
    State processEvent(OrderEvent event);
    TimePoint getStateEnterTime(State state) const;
    vector<StateTransition> getTransitionHistory() const;
};
```

**性能要求：**
- **订单处理延迟：** P99 < 200μs（从请求到发送给CTP）
- **状态更新延迟：** < 50μs（从CTP回调到内存更新）
- **订单查询延迟：** < 100μs（内存查询）
- **最大并发订单：** > 10,000个活跃订单
- **状态同步时间：** < 1秒（全量同步）
- **故障恢复时间：** < 5秒（引擎重启恢复）

**依赖关系：**
- 依赖CTP API封装器执行订单操作
- 依赖风控服务进行事前风控检查
- 为策略层提供订单执行接口

### 2.3 风控服务

**职责描述：**
实时监控资金、持仓和交易行为，执行风控规则，防止异常交易和监管违规。

**核心功能：**
- **实时风控检查：** 订单前置检查、交易中监控、事后分析
- **资金监控：** 保证金使用率、风险度、可用资金监控
- **持仓监控：** 单合约持仓限额、总持仓限额、交易所限额
- **交易行为监控：** 频繁报撤单、自成交、异常价格等行为检测
- **监管合规检查：** 内嵌《期货和衍生品法》合规逻辑

**接口定义：**
```cpp
class RiskControlService {
public:
    // 风控检查
    RiskCheckResult preTradeCheck(const OrderRequest& request);
    RiskCheckResult intraTradeCheck(const TradeContext& context);
    RiskCheckResult postTradeCheck(const TradeRecord& record);
    
    // 监控接口
    RiskMetrics getCurrentRiskMetrics() const;
    vector<RiskAlert> getActiveAlerts() const;
    RiskReport generateDailyReport() const;
    
    // 规则管理
    void addRule(const shared_ptr<RiskRule>& rule);
    void removeRule(const string& ruleID);
    void updateRule(const string& ruleID, const RiskRuleConfig& config);
    vector<RuleStatus> getAllRuleStatus() const;
    
    // 事件处理
    void handleRiskEvent(const RiskEvent& event);
    void acknowledgeAlert(const string& alertID, const string& operatorID);
    
    // 紧急控制
    void emergencyStop();  // 紧急停止所有交易
    void suspendStrategy(const string& strategyID);
    void resumeStrategy(const string& strategyID);
};

// 风控规则基类
class RiskRule {
public:
    virtual RiskCheckResult check(const CheckContext& context) = 0;
    virtual string getRuleID() const = 0;
    virtual string getDescription() const = 0;
    virtual Severity getSeverity() const = 0;
    
    // 规则配置
    virtual void configure(const RuleConfig& config) = 0;
    virtual RuleConfig getConfig() const = 0;
};

// 具体规则示例：持仓限额规则
class PositionLimitRule : public RiskRule {
public:
    PositionLimitRule(const string& instrumentID, int64_t limit);
    
    RiskCheckResult check(const CheckContext& context) override {
        auto currentPos = context.getPosition(instrumentID_);
        if (abs(currentPos) > limit_) {
            return RiskCheckResult::reject(
                "Position limit exceeded",
                Severity::HIGH
            );
        }
        return RiskCheckResult::pass();
    }
};
```

**性能要求：**
- **风控检查延迟：** P99 < 50μs（单规则检查）
- **复合检查延迟：** < 200μs（多规则并行检查）
- **监控更新频率：** 100Hz（实时监控）
- **告警生成延迟：** < 10ms（从检测到告警）
- **规则数量支持：** > 1000个活跃规则
- **历史数据查询：** < 1ms（最近24小时数据）

**依赖关系：**
- 依赖订单引擎获取交易数据
- 依赖行情引擎获取市场数据
- 为所有交易操作提供事前风控

### 2.4 市场状态识别引擎

**职责描述：**
基于AI驱动的七维状态空间模型，实时识别市场状态，为策略提供高质量的市场环境信号。参考幻方量化2026-02-09市场状态识别引擎升级方案。

**核心功能：**
- **七维状态识别：** 趋势、波动率、流动性、情绪、季节性、技术形态、事件驱动
- **AI模型推理：** Transformer+LSTM混合模型，支持GPU加速
- **实时特征计算：** Tick级特征提取，多时间尺度分析
- **状态空间维护：** 七维状态向量实时更新和维护
- **自适应学习：** 在线学习与模型动态调整

**七维状态空间详细定义：**
1. **趋势维度：** 多时间尺度（1min, 5min, 15min）趋势方向与强度，采用Hurst指数、ADF检验等量化
2. **波动率维度：** GARCH模型实时波动率估计，regime切换检测（低波/中波/高波状态）
3. **流动性维度：** 订单簿深度、买卖价差、成交活跃度、大单冲击成本
4. **情绪维度：** 市场情绪指数（基于交易行为）、新闻情感分析（实时新闻流）
5. **季节性维度：** 日内模式（开盘/午盘/收盘效应）、周内效应、季节性因子
6. **技术形态维度：** 经典技术形态识别（头肩顶、双底等）与置信度评估
7. **事件驱动维度：** 宏观经济事件影响、政策公告、行业新闻的实时评估

**接口定义：**
```cpp
class MarketStateEngine {
public:
    // 状态查询
    MarketStateVector getCurrentState(const string& instrumentID) const;
    MarketStateHistory getStateHistory(const string& instrumentID, 
                                       TimeRange range) const;
    
    // 状态订阅
    SubscriptionHandle subscribeState(const string& instrumentID,
                                      StateCallback callback,
                                      UpdateFrequency frequency = UpdateFrequency::TICK);
    void unsubscribe(SubscriptionHandle handle);
    
    // 引擎控制
    void start();
    void stop();
    void reloadModel(const string& modelPath);  // 热更新模型
    
    // 模型管理
    ModelInfo getModelInfo() const;
    PerformanceMetrics getModelPerformance() const;
    void triggerRetraining();  // 触发模型重训练
    
    // 特征访问
    FeatureVector getRawFeatures(const string& instrumentID) const;
};

// 七维状态向量
struct MarketStateVector {
    // 趋势维度 (0.0-1.0)
    struct {
        double direction;      // 方向：-1.0(强烈下跌)到1.0(强烈上涨)
        double strength;       // 强度：0.0(无趋势)到1.0(强趋势)
        double confidence;     // 置信度：0.0-1.0
        map<string, double> subTrends; // 子时间尺度趋势
    } trend;
    
    // 波动率维度
    struct {
        double level;          // 波动率水平：0.0(极低)到1.0(极高)
        string regime;         // 状态："low", "medium", "high", "extreme"
        double regimeConfidence; // 状态置信度
        double garchSigma;     // GARCH模型sigma估计
    } volatility;
    
    // 流动性维度
    struct {
        double score;          // 流动性综合评分：0.0(极差)到1.0(极好)
        double bidAskSpread;   // 买卖价差（相对值）
        double orderBookDepth; // 订单簿深度评分
        double tradeActivity;  // 成交活跃度
        double largeOrderImpact; // 大单冲击成本
    } liquidity;
    
    // 情绪维度
    struct {
        double sentiment;      // 情绪指数：-1.0(极度悲观)到1.0(极度乐观)
        double newsSentiment;  // 新闻情绪得分
        double socialSentiment; // 社交媒体情绪
        double fearGreedIndex; // 恐惧贪婪指数
    } sentiment;
    
    // 季节性维度
    struct {
        double intradayFactor;   // 日内因子
        double dayOfWeekFactor;  // 周内因子
        double seasonalFactor;   // 季节性因子
        map<string, double> patternStrengths; // 特定模式强度
    } seasonality;
    
    // 技术形态维度
    struct {
        map<string, double> patternConfidences; // 技术形态置信度
        string dominantPattern;  // 主导形态
        double patternStrength;  // 形态强度
        TimePoint patternStart;  // 形态开始时间
    } technicalPattern;
    
    // 事件驱动维度
    struct {
        double eventImpact;     // 事件综合影响：-1.0(重大负面)到1.0(重大正面)
        map<string, double> specificImpacts; // 具体事件影响
        vector<Event> activeEvents; // 活跃事件列表
    } eventDriven;
    
    // 元数据
    TimePoint timestamp;
    string instrumentID;
    double overallConfidence;   // 整体状态置信度
};
```

**AI模型架构细节：**
```
输入层 (500维特征向量)
    ↓
特征预处理层 (BatchNorm + Dropout)
    ↓
共享特征提取层 (Transformer编码器，4层，256隐藏维度，8头注意力)
    ↓
任务特定头层 (并行7个Dense头，各128维)
    ↓
输出层 [趋势(3维), 波动率(4维), 流动性(5维), 情绪(4维), 季节性(4维), 技术形态(4维), 事件驱动(3维)]
```

**性能要求：**
- **状态识别延迟：** < 10μs（GPU加速），< 50μs（CPU推理）
- **特征计算延迟：** < 5μs（Tick级特征）
- **状态更新频率：** Tick级实时更新（~500ms）
- **模型推理吞吐：** > 1000次推理/秒（单GPU）
- **内存占用：** < 500MB（模型+特征缓存）
- **在线学习延迟：** < 100ms（增量更新）

**依赖关系：**
- 依赖行情引擎提供Tick数据和订单簿
- 依赖网络通信管理器获取新闻和事件数据
- 为策略层提供高质量市场状态信号

## 3. 策略研究层模块

策略研究层提供完整的策略开发、回测和分析工具链，支持从研究到生产的全流程。

### 3.1 因子计算框架

**职责描述：**
提供丰富的技术指标库和特征工程流水线，支持实时因子计算和历史因子分析。

**核心功能：**
- **技术指标库：** 200+技术指标实现（移动平均、振荡器、波动率、成交量等）
- **特征工程流水线：** 可配置的特征计算管道，支持复杂因子组合
- **实时因子计算：** Tick级因子实时计算和更新
- **因子分析工具：** IC分析、换手率分析、衰减分析等
- **因子存储管理：** 因子数据存储、版本管理和共享

**接口定义：**
```python
# Python接口（策略层使用）
class FactorCalculator:
    def __init__(self, config: FactorConfig):
        self.indicators = IndicatorLibrary()
        self.pipeline = FeaturePipeline()
        
    def calculate_realtime(self, market_data: MarketData) -> Dict[str, float]:
        """实时计算因子值"""
        pass
    
    def calculate_historical(self, 
                           history_data: pd.DataFrame,
                           factors: List[str]) -> pd.DataFrame:
        """历史因子计算"""
        pass
    
    def analyze_factor(self, 
                      factor_data: pd.DataFrame,
                      returns: pd.Series) -> FactorAnalysisReport:
        """因子分析（IC、换手率、衰减等）"""
        pass
    
    def create_custom_factor(self, 
                           expression: str,
                           dependencies: List[str]) -> CustomFactor:
        """创建自定义因子（DSL支持）"""
        pass

# 技术指标库示例
class IndicatorLibrary:
    # 移动平均类
    def sma(self, series: pd.Series, period: int) -> pd.Series:
        pass
    
    def ema(self, series: pd.Series, period: int) -> pd.Series:
        pass
    
    def wma(self, series: pd.Series, period: int) -> pd.Series:
        pass
    
    # 振荡器类
    def rsi(self, series: pd.Series, period: int) -> pd.Series:
        pass
    
    def macd(self, series: pd.Series, 
             fast: int = 12, slow: int = 26, signal: int = 9) -> pd.DataFrame:
        pass
    
    # 波动率类
    def bollinger_bands(self, series: pd.Series, 
                        period: int = 20, 
                        std_dev: float = 2.0) -> pd.DataFrame:
        pass
    
    def atr(self, high: pd.Series, low: pd.Series, 
            close: pd.Series, period: int = 14) -> pd.Series:
        pass
    
    # 订单簿因子
    def order_book_imbalance(self, bids: List[Tuple], asks: List[Tuple]) -> float:
        pass
    
    def micro_price(self, bids: List[Tuple], asks: List[Tuple]) -> float:
        pass
    
    def volume_imbalance(self, bids: List[Tuple], asks: List[Tuple]) -> float:
        pass
```

**性能要求：**
- **实时计算延迟：** < 100μs（单因子计算）
- **历史计算速度：** > 1百万行/秒（批量计算）
- **内存使用：** < 2GB（全市场因子缓存）
- **并发计算：** 支持多核并行计算
- **因子数量：** 支持同时计算 > 500个因子

**依赖关系：**
- 依赖行情引擎提供市场数据
- 依赖数据存储层持久化因子数据
- 为回测引擎和策略提供因子数据

### 3.2 回测引擎

**职责描述：**
提供事件驱动的回测框架，支持分钟级K线回测，包含完整的交易成本模型和现实约束。

**核心功能：**
- **事件驱动架构：** 基于时间事件和价格事件的双驱动模型
- **分钟级K线回测：** 支持1分钟、5分钟、15分钟等多粒度回测
- **现实约束模拟：** 包含手续费、滑点、限价单成交概率等现实因素
- **多策略回测：** 支持多个策略同时回测，考虑策略间影响
- **性能分析：** 内置丰富的绩效分析指标

**接口定义：**
```python
class BacktestEngine:
    def __init__(self, config: BacktestConfig):
        self.event_loop = EventLoop()
        self.data_feed = DataFeed()
        self.portfolio = Portfolio()
        self.performance_tracker = PerformanceTracker()
        
    def run(self, 
            strategy: Strategy,
            start_date: datetime,
            end_date: datetime) -> BacktestResult:
        """运行回测"""
        pass
    
    def run_walk_forward(self,
                        strategy: Strategy,
                        windows: List[Tuple[datetime, datetime]]) -> WalkForwardResult:
        """运行Walk-Forward回测"""
        pass
    
    def optimize_parameters(self,
                          strategy_class: Type[Strategy],
                          param_space: Dict[str, List[Any]],
                          start_date: datetime,
                          end_date: datetime) -> OptimizationResult:
        """参数优化（支持并行优化）"""
        pass
    
    def add_constraint(self, constraint: Constraint):
        """添加现实约束（如资金限制、持仓限制等）"""
        pass
    
    def get_trade_log(self) -> pd.DataFrame:
        """获取交易日志"""
        pass

# 策略基类
class Strategy(ABC):
    @abstractmethod
    def initialize(self, context: Context):
        """策略初始化"""
        pass
    
    @abstractmethod
    def handle_data(self, context: Context, data: Dict[str, BarData]):
        """处理市场数据"""
        pass
    
    def before_trading_start(self, context: Context):
        """盘前处理"""
        pass
    
    def after_trading_end(self, context: Context):
        """盘后处理"""
        pass
    
    # 交易接口
    def order(self, context: Context, asset: str, amount: float):
        pass
    
    def order_target(self, context: Context, asset: str, target: float):
        pass
    
    def order_percent(self, context: Context, asset: str, percent: float):
        pass

# 现实约束示例
class RealisticConstraint(Constraint):
    def __init__(self, 
                 commission_rate: float = 0.0003,  # 万三手续费
                 slippage: float = 0.0001,         # 万分之一滑点
                 min_trade_size: int = 1,          # 最小交易手数
                 price_limit: bool = True):        # 价格限制（涨跌停）
        pass
    
    def apply(self, 
              order: Order,
              data: MarketData,
              portfolio: Portfolio) -> Order:
        """应用现实约束，返回调整后的订单"""
        # 1. 应用手续费
        # 2. 应用滑点
        # 3. 检查最小交易手数
        # 4. 检查价格限制
        # 5. 检查流动性（大单拆分）
        pass
```

**性能要求：**
- **回测速度：** > 100倍实时（1年数据回测 < 3天）
- **内存使用：** < 4GB（大型回测场景）
- **数据加载速度：** < 30秒（加载1年分钟线数据）
- **并发回测：** 支持同时运行多个回测任务
- **参数优化速度：** > 1000组参数/小时

**依赖关系：**
- 依赖因子计算框架计算策略因子
- 依赖数据存储层获取历史数据
- 为策略研究提供验证环境

### 3.3 绩效分析体系

**职责描述：**
提供全面的绩效分析工具，计算风险调整后收益指标，生成可视化报告。

**核心功能：**
- **收益分析：** 年化收益率、累计收益率、超额收益率计算
- **风险分析：** 波动率、最大回撤、VaR、CVaR等风险指标
- **风险调整后收益：** 夏普比率、索提诺比率、卡玛比率等
- **归因分析：** 收益归因、风险归因、Brinson归因
- **可视化报告：** 自动生成PDF/HTML格式的绩效报告

**接口定义：**
```python
class PerformanceAnalyzer:
    def __init__(self, returns: pd.Series, benchmark: Optional[pd.Series] = None):
        self.returns = returns
        self.benchmark = benchmark
        
    def calculate_basic_metrics(self) -> Dict[str, float]:
        """计算基础绩效指标"""
        metrics = {}
        metrics['total_return'] = self._calculate_total_return()
        metrics['annual_return'] = self._calculate_annual_return()
        metrics['annual_volatility'] = self._calculate_annual_volatility()
        metrics['sharpe_ratio'] = self._calculate_sharpe_ratio()
        metrics['max_drawdown'] = self._calculate_max_drawdown()
        metrics['calmar_ratio'] = self._calculate_calmar_ratio()
        return metrics
    
    def calculate_advanced_metrics(self) -> Dict[str, float]:
        """计算高级绩效指标"""
        metrics = {}
        metrics['sortino_ratio'] = self._calculate_sortino_ratio()
        metrics['omega_ratio'] = self._calculate_omega_ratio()
        metrics['var_95'] = self._calculate_var(0.95)
        metrics['cvar_95'] = self._calculate_cvar(0.95)
        metrics['skewness'] = self._calculate_skewness()
        metrics['kurtosis'] = self._calculate_kurtosis()
        return metrics
    
    def perform_attribution_analysis(self, 
                                   portfolio_returns: pd.Series,
                                   factor_returns: pd.DataFrame) -> AttributionResult:
        """进行归因分析"""
        pass
    
    def generate_report(self, 
                       format: str = 'html',
                       template: Optional[str] = None) -> Report:
        """生成绩效报告"""
        pass
    
    def plot_performance(self, 
                        figsize: Tuple[int, int] = (12, 8)) -> matplotlib.figure.Figure:
        """绘制绩效图表"""
        pass

# 绩效报告类
class PerformanceReport:
    def __init__(self, analyzer: PerformanceAnalyzer):
        self.analyzer = analyzer
        self.metrics = analyzer.calculate_all_metrics()
        self.charts = analyzer.generate_all_charts()
        
    def to_html(self) -> str:
        """生成HTML报告"""
        pass
    
    def to_pdf(self, filepath: str):
        """生成PDF报告"""
        pass
    
    def to_excel(self, filepath: str):
        """生成Excel报告"""
        pass

# 风险指标计算
class RiskMetricsCalculator:
    @staticmethod
    def calculate_var(returns: pd.Series, 
                     confidence_level: float = 0.95,
                     method: str = 'historical') -> float:
        """计算VaR（在险价值）"""
        pass
    
    @staticmethod
    def calculate_cvar(returns: pd.Series,
                      confidence_level: float = 0.95,
                      method: str = 'historical') -> float:
        """计算CVaR（条件在险价值）"""
        pass
    
    @staticmethod
    def calculate_expected_shortfall(returns: pd.Series,
                                   confidence_level: float = 0.95) -> float:
        """计算预期损失"""
        pass
    
    @staticmethod
    def calculate_ulcer_index(returns: pd.Series) -> float:
        """计算溃疡指数"""
        pass
```

**性能要求：**
- **指标计算速度：** < 100ms（计算1000个交易日数据）
- **报告生成速度：** < 5秒（生成完整HTML报告）
- **内存使用：** < 1GB（大型分析场景）
- **可视化渲染：** < 2秒（生成交互式图表）
- **并发分析：** 支持多个分析任务并行

**依赖关系：**
- 依赖回测引擎提供交易记录和收益数据
- 依赖可视化库生成图表
- 为策略评估提供量化工具

## 4. 运维监控层模块

运维监控层保障系统稳定运行，提供全面的可观测性、日志管理和告警能力。

### 4.1 指标采集器

**职责描述：**
实现Prometheus exporter，采集系统各组件性能指标，为监控和告警提供数据基础。

**核心功能：**
- **自定义指标采集：** 采集延迟、吞吐量、错误率等业务指标
- **系统指标采集：** CPU、内存、磁盘、网络等系统资源指标
- **应用指标采集：** 各服务内部状态、队列长度、缓存命中率等
- **指标暴露：** 通过HTTP端点暴露Prometheus格式指标
- **指标聚合：** 多实例指标聚合和标签管理

**接口定义：**
```cpp
class MetricsCollector {
public:
    // 指标注册
    CounterHandle registerCounter(const string& name, 
                                  const string& help,
                                  const map<string, string>& labels = {});
    
    GaugeHandle registerGauge(const string& name,
                              const string& help,
                              const map<string, string>& labels = {});
    
    HistogramHandle registerHistogram(const string& name,
                                      const string& help,
                                      const vector<double>& buckets,
                                      const map<string, string>& labels = {});
    
    SummaryHandle registerSummary(const string& name,
                                  const string& help,
                                  const vector<double>& quantiles,
                                  const map<string, string>& labels = {});
    
    // 指标操作
    void increment(CounterHandle handle, double value = 1.0);
    void set(GaugeHandle handle, double value);
    void observe(HistogramHandle handle, double value);
    void observe(SummaryHandle handle, double value);
    
    // 数据暴露
    string exportPrometheusFormat() const;
    void startHTTPServer(int port = 9100);
    
    // 指标管理
    vector<MetricInfo> listMetrics() const;
    optional<MetricData> getMetricData(const string& name) const;
    
    // 自动采集
    void startAutoCollection();
    void stopAutoCollection();
};

// 应用特定指标
class TradingMetrics {
public:
    // 行情相关指标
    CounterHandle tick_received;
    CounterHandle tick_processed;
    HistogramHandle tick_processing_latency;
    GaugeHandle active_subscriptions;
    
    // 订单相关指标
    CounterHandle orders_placed;
    CounterHandle orders_filled;
    CounterHandle orders_cancelled;
    CounterHandle orders_rejected;
    HistogramHandle order_latency;
    
    // 风控指标
    CounterHandle risk_checks_passed;
    CounterHandle risk_checks_failed;
    CounterHandle risk_alerts_triggered;
    GaugeHandle current_risk_score;
    
    // 系统健康指标
    GaugeHandle memory_usage_mb;
    GaugeHandle cpu_usage_percent;
    GaugeHandle queue_length;
    GaugeHandle connection_count;
};
```

**性能要求：**
- **指标采集延迟：** < 10μs（单指标更新）
- **指标暴露延迟：** < 1ms（HTTP端点响应）
- **内存占用：** < 100MB（10万指标场景）
- **采集频率：** 支持1Hz-1000Hz可配置采集
- **指标数量：** 支持 > 10万个活跃指标
- **网络开销：** < 1MB/分钟（指标数据）

**依赖关系：**
- 依赖Prometheus客户端库
- 依赖各业务组件提供指标数据
- 为监控仪表板和告警系统提供数据源

### 4.2 日志聚合器

**职责描述：**
实现结构化日志采集、聚合和分析，提供审计追踪和故障排查能力。

**核心功能：**
- **结构化日志：** JSON格式结构化日志，支持丰富字段
- **日志分级：** DEBUG、INFO、WARN、ERROR、FATAL多级日志
- **审计追踪：** 关键操作审计日志，满足监管要求
- **日志聚合：** 多实例日志聚合和统一管理
- **日志分析：** 实时日志分析和模式识别

**接口定义：**
```cpp
class Logger {
public:
    // 日志记录
    void debug(const string& message, const LogContext& context = {});
    void info(const string& message, const LogContext& context = {});
    void warn(const string& message, const LogContext& context = {});
    void error(const string& message, const LogContext& context = {});
    void fatal(const string& message, const LogContext& context = {});
    
    // 结构化字段
    void withField(const string& key, const string& value);
    void withFields(const map<string, string>& fields);
    
    // 审计日志
    void audit(const string& operation,
               const string& user,
               const string& resource,
               const AuditContext& context = {});
    
    // 性能日志
    void performance(const string& operation,
                     microseconds duration,
                     const PerformanceContext& context = {});
    
    // 配置管理
    void setLevel(LogLevel level);
    void addAppender(const shared_ptr<LogAppender>& appender);
    void removeAppender(const string& name);
    
    // 上下文管理（RAII风格）
    class ScopedContext {
    public:
        ScopedContext(const map<string, string>& fields);
        ~ScopedContext();
    };
};

// 日志附加器
class LogAppender {
public:
    virtual void append(const LogRecord& record) = 0;
    virtual string getName() const = 0;
    virtual void flush() = 0;
    virtual void close() = 0;
};

// 具体实现
class FileAppender : public LogAppender {
public:
    FileAppender(const string& filepath, 
                 size_t maxSize = 100 * 1024 * 1024,  // 100MB
                 size_t maxFiles = 10);
    
    void append(const LogRecord& record) override;
    void flush() override;
    
private:
    void rotateIfNeeded();
};

class ElasticsearchAppender : public LogAppender {
public:
    ElasticsearchAppender(const string& endpoint,
                          const string& indexPattern = "logs-{YYYY.MM.dd}");
    
    void append(const LogRecord& record) override;
    void flush() override;
};

// 审计追踪
class AuditTrail {
public:
    void recordOperation(const AuditRecord& record);
    vector<AuditRecord> queryOperations(const AuditQuery& query) const;
    AuditReport generateAuditReport(const TimeRange& range) const;
    
    // 监管合规
    bool verifyAuditIntegrity(const TimeRange& range) const;
    vector<AuditIssue> findAuditIssues(const TimeRange& range) const;
};
```

**性能要求：**
- **日志记录延迟：** P99 < 10μs（异步记录）
- **日志吞吐量：** > 100,000条/秒
- **磁盘写入延迟：** < 1ms（缓冲写入）
- **日志查询延迟：** < 100ms（最近1小时日志）
- **审计完整性：** 100%（无日志丢失）
- **存储效率：** 压缩率 > 80%（JSON日志压缩）

**依赖关系：**
- 依赖Elasticsearch进行日志存储和检索
- 依赖Filebeat进行日志收集
- 为所有系统组件提供日志服务

### 4.3 告警管理器

**职责描述：**
实现多级告警规则管理，支持多种通知渠道，及时响应系统异常。

**核心功能：**
- **告警规则定义：** 支持阈值、变化率、异常检测等多种规则类型
- **多级告警：** 警告、严重、紧急等多级别告警
- **通知渠道：** 支持邮件、短信、钉钉、企业微信、Slack等
- **告警抑制：** 告警抑制、去重、分组、升级机制
- **告警历史：** 告警历史记录和统计分析

**接口定义：**
```cpp
class AlertManager {
public:
    // 告警规则管理
    string addRule(const AlertRule& rule);
    void updateRule(const string& ruleID, const AlertRule& rule);
    void deleteRule(const string& ruleID);
    vector<AlertRule> getAllRules() const;
    optional<AlertRule> getRule(const string& ruleID) const;
    
    // 告警触发
    void triggerAlert(const Alert& alert);
    void resolveAlert(const string& alertID, const string& resolver = "");
    
    // 告警查询
    vector<Alert> getActiveAlerts() const;
    vector<Alert> getHistoricalAlerts(const TimeRange& range) const;
    AlertStats getAlertStats(const TimeRange& range) const;
    
    // 通知管理
    void addNotifier(const shared_ptr<Notifier>& notifier);
    void removeNotifier(const string& notifierID);
    vector<NotifierInfo> getNotifiers() const;
    
    // 告警处理
    void acknowledgeAlert(const string& alertID, const string& operatorID);
    void escalateAlert(const string& alertID);
    void silenceAlert(const string& alertID, minutes duration);
    
    // 配置管理
    void loadConfig(const string& configPath);
    void saveConfig(const string& configPath) const;
};

// 告警规则
class AlertRule {
public:
    string id;
    string name;
    string description;
    Severity severity;
    
    // 条件定义
    struct Condition {
        string metricName;
        enum class Operator {
            GT,  // 大于
            LT,  // 小于
            EQ,  // 等于
            NEQ, // 不等于
            CHANGE_GT, // 变化大于
            CHANGE_LT  // 变化小于
        } op;
        double threshold;
        Duration duration;  // 持续多久触发
    };
    
    vector<Condition> conditions;
    Duration evaluationInterval;  // 评估间隔
    Duration repeatInterval;      // 重复告警间隔
    bool enabled;
    
    // 通知配置
    struct Notification {
        vector<string> notifierIDs;
        string template;  // 通知模板
        bool escalate;    // 是否升级
    } notification;
};

// 通知器接口
class Notifier {
public:
    virtual bool send(const Notification& notification) = 0;
    virtual string getName() const = 0;
    virtual string getType() const = 0;
    virtual bool testConnection() = 0;
};

// 具体通知器实现
class EmailNotifier : public Notifier {
public:
    EmailNotifier(const EmailConfig& config);
    
    bool send(const Notification& notification) override {
        // 发送邮件
        return true;
    }
};

class DingTalkNotifier : public Notifier {
public:
    DingTalkNotifier(const DingTalkConfig& config);
    
    bool send(const Notification& notification) override {
        // 发送钉钉消息
        return true;
    }
};

class SMSCNotifier : public Notifier {
public:
    SMSCNotifier(const SMSConfig& config);
    
    bool send(const Notification& notification) override {
        // 发送短信
        return true;
    }
};
```

**性能要求：**
- **告警评估延迟：** < 100ms（单规则评估）
- **告警触发延迟：** < 1秒（从检测到通知发出）
- **通知发送延迟：** P99 < 5秒（各种渠道）
- **规则数量支持：** > 1000个活跃告警规则
- **并发告警处理：** > 100个告警/秒
- **历史数据保留：** > 90天告警历史

**依赖关系：**
- 依赖指标采集器获取监控数据
- 依赖各种通知服务提供商
- 为运维团队提供及时告警

## 5. 模块间依赖关系与数据流向

### 5.1 核心数据流

```
CTP API → CTP API封装器 → 行情引擎 → 市场状态识别引擎 → 策略层
                         ↓                     ↓
                   订单引擎 ← 风控服务      因子计算框架
                         ↓                     ↓
                   穿透式监管集成器       回测引擎 → 绩效分析体系
                         ↓                     ↓
                   监管上报系统           研究报告
```

### 5.2 横向依赖矩阵

| 模块 | 依赖的模块 | 提供的服务 |
|------|------------|------------|
| CTP API封装器 | 无（最底层） | 行情数据、交易接口 |
| 穿透式监管集成器 | CTP API封装器 | 监管数据采集上报 |
| 网络通信管理器 | 无（基础设施） | 进程间/网络通信 |
| 行情引擎 | CTP API封装器、网络通信管理器 | 标准化行情数据 |
| 订单引擎 | CTP API封装器、风控服务 | 订单执行管理 |
| 风控服务 | 行情引擎、订单引擎 | 风控检查决策 |
| 市场状态识别引擎 | 行情引擎、网络通信管理器 | 七维市场状态 |
| 因子计算框架 | 行情引擎、数据存储 | 技术因子计算 |
| 回测引擎 | 因子计算框架、数据存储 | 策略回测验证 |
| 绩效分析体系 | 回测引擎 | 绩效评估报告 |
| 指标采集器 | 所有业务模块 | 监控指标暴露 |
| 日志聚合器 | 所有业务模块 | 日志收集分析 |
| 告警管理器 | 指标采集器 | 异常告警通知 |

### 5.3 性能关键路径

1. **行情处理路径：** CTP API → 行情引擎 → 市场状态识别引擎 → 策略
   - 目标延迟：P99 < 2ms
   - 关键优化：零拷贝数据传递、内存池、SIMD指令优化

2. **订单执行路径：** 策略 → 风控服务 → 订单引擎 → CTP API
   - 目标延迟：P99 < 5ms
   - 关键优化：异步流水线、并行风控检查、连接池复用

3. **监控告警路径：** 指标采集 → 告警评估 → 通知发送
   - 目标延迟：P99 < 10秒
   - 关键优化：流式处理、批量通知、缓存优化

## 6. 实施优先级与资源分配

### 6.1 阶段一：基础设施搭建（第1-2月）
- **高优先级：** CTP API封装器、穿透式监管集成器、网络通信管理器
- **中优先级：** 行情引擎、订单引擎基础功能
- **低优先级：** 基础监控（指标采集器、日志聚合器）

### 6.2 阶段二：核心服务完善（第3-4月）
- **高优先级：** 风控服务、市场状态识别引擎原型
- **中优先级：** 订单引擎高级功能、行情引擎优化
- **低优先级：** 告警管理器基础功能

### 6.3 阶段三：策略研究平台（第5-6月）
- **高优先级：** 因子计算框架、回测引擎
- **中优先级：** 绩效分析体系、高级监控功能
- **低优先级：** 研究可视化工具

### 6.4 阶段四：系统集成优化（第7-8月）
- **高优先级：** 全链路集成测试、性能优化
- **中优先级：** 监控告警完善、文档完善
- **低优先级：** 高级功能扩展

## 7. 质量保证与验收标准

### 7.1 性能验收标准
- **基础设施层：** CTP API封装器连接成功率 > 99.9%，重连时间 < 10秒
- **核心服务层：** 行情引擎Tick处理延迟P99 < 100μs，市场状态识别延迟 < 10μs
- **策略研究层：** 回测引擎速度 > 100倍实时，因子计算延迟 < 100μs
- **运维监控层：** 指标采集延迟 < 10μs，告警触发延迟 < 1秒

### 7.2 可靠性验收标准
- **可用性：** 核心交易功能可用性 > 99.95%（年停机 < 4.38小时）
- **数据完整性：** 监管数据完整性100%，交易数据零丢失
- **故障恢复：** 系统故障恢复时间 < 5分钟
- **容错能力：** 单点故障不影响核心交易功能

### 7.3 可维护性验收标准
- **文档完整性：** 每个模块API文档、设计文档、运维手册完整
- **测试覆盖率：** 单元测试覆盖率 > 80%，集成测试覆盖率 > 90%
- **监控覆盖：** 所有关键功能监控指标覆盖100%
- **日志可查性：** 所有关键操作有审计日志，支持完整追踪

---

**文档版本：** v1.0  
**最后更新：** 2026-02-10  
**负责人：** 系统架构师  
**状态：** 草案 - 待技术评审  
**关联文档：** 
- [00-项目总览与设计原则.md](../00-项目总览与设计原则.md)
- [01-01-整体架构图与技术栈选型.md](01-01-整体架构图与技术栈选型.md)

**技术决策记录：**
- 2026-02-10: 确定四层模块划分（基础设施、核心服务、策略研究、运维监控）
- 2026-02-10: 详细定义七维市场状态识别引擎模块接口
- 2026-02-10: 明确CTP API封装器与穿透式监管集成器设计
- 2026-02-10: 制定各模块性能指标和验收标准
