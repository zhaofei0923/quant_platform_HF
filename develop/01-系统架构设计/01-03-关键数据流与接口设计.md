# 关键数据流与接口设计

## 对齐信息

- 对齐基线：main@17f0f8c957a4c0f95ebb054725f04b21e0e6861b
- 实现状态：部分落地
- 证据路径：`src/apps/core_engine_main.cpp`、`include/quant_hft/interfaces/`、`proto/quant_hft/v1/contracts.proto`、`python/quant_hft/runtime/strategy_runner.py`
- 最后更新：2026-02-11

## 当前实现边界

当前已落地的关键数据流为“行情 -> 状态 -> 策略意图 -> 风控/下单 -> 订单回报”闭环。文档内其他更复杂链路视为规划内容。

## 已落地数据流

### 1. 行情与状态流（C++）

1. `IMarketDataGateway` 回调行情。
2. 行情写入 `IRealtimeCache` 与 `ITimeseriesStore`。
3. `IMarketStateEngine` 输出 `StateSnapshot7D`。
4. `StateSnapshot7D` 写入 Redis key：`market:state7d:<instrument>:latest`。

### 2. 策略桥流（Python + C++）

1. Python runner 轮询 `market:state7d:*`。
2. `StrategyRuntime` 调用 `StrategyBase.on_state` 产生 `SignalIntent`。
3. 写入 `strategy:intent:<strategy_id>:latest`（`seq/count/intent_i`）。
4. C++ `StrategyIntentInbox` 拉取并解码。
5. 转换为 `OrderIntent` 后进入风控与状态机。
6. 订单回报写入 `trade:order:<trace_id>:info`，Python runner 回调 `on_order_event`。

### 3. 关键接口（已实现）

- C++：`IRealtimeCache`、`ITimeseriesStore`、`IRiskEngine`、`IOrderGateway`。
- C++ bridge：`StrategyIntentCodec`、`StrategyIntentInbox`。
- Python：`StrategyBase`、`StrategyRuntime`、`StrategyRunner`。

Redis schema 以 `docs/STRATEGY_BRIDGE_REDIS_PROTOCOL.md` 为准。

## 规划内容（未落地）

1. 多策略并发调度下的公平性与资源隔离。
2. 回报补偿重放与跨进程幂等事务协同。
3. 更复杂数据总线与流处理编排。

## 落地依赖条件

- 先冻结 Redis 协议字段、序列号语义、trace_id 唯一约束。
- 明确故障场景下的重试与去重策略。
- 对跨进程事件建立可观测指标与回放工具。

## 进入实现阶段触发条件

- 对目标流提供可执行时序图与失败路径处理。
- 新流程必须附带单测和最小端到端演示脚本。
- 文档中声明“已落地”前需提供代码证据路径。
