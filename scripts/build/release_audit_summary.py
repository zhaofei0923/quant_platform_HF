#!/usr/bin/env python3
from __future__ import annotations

import argparse
import hashlib
import json
import tarfile
from pathlib import Path


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate release audit markdown from non-hotpath bundle and manifest"
    )
    parser.add_argument("--bundle", required=True, help="Path to bundle .tar.gz")
    parser.add_argument(
        "--checksum",
        default="",
        help="Path to sha256 file generated by sha256sum (default: <bundle>.sha256)",
    )
    parser.add_argument(
        "--output",
        default="",
        help="Write markdown output to file (default: stdout only)",
    )
    parser.add_argument(
        "--json-output",
        default="",
        help="Write structured JSON summary to file (optional)",
    )
    return parser.parse_args()


def _read_expected_checksum(checksum_path: Path) -> str:
    line = checksum_path.read_text(encoding="utf-8").strip()
    token = line.split()[0] if line else ""
    if len(token) != 64:
        raise ValueError("checksum file missing valid sha256 token")
    return token.lower()


def _compute_sha256(path: Path) -> str:
    sha256 = hashlib.sha256()
    with path.open("rb") as handle:
        while True:
            chunk = handle.read(1024 * 1024)
            if not chunk:
                break
            sha256.update(chunk)
    return sha256.hexdigest()


def _extract_manifest(bundle_path: Path) -> tuple[str, dict[str, object]]:
    with tarfile.open(bundle_path, "r:gz") as archive:
        members = archive.getnames()
        roots = {name.split("/", 1)[0] for name in members if name}
        roots.discard("")
        if len(roots) != 1:
            raise ValueError("bundle must contain exactly one top-level directory")
        (root_dir,) = tuple(roots)
        manifest_member = f"{root_dir}/deploy/release_manifest.json"
        handle = archive.extractfile(manifest_member)
        if handle is None:
            raise ValueError("manifest file is missing in bundle")
        with handle:
            payload = json.load(handle)
    if not isinstance(payload, dict):
        raise ValueError("manifest must be a JSON object")
    return root_dir, payload


def _as_list(value: object) -> list[str]:
    if isinstance(value, list):
        return [str(item) for item in value]
    return []


def _build_markdown(
    *,
    bundle_path: Path,
    actual_checksum: str,
    root_dir: str,
    manifest: dict[str, object],
) -> str:
    components = _as_list(manifest.get("components"))
    lines = [
        "# Release Audit Summary",
        "",
        f"- Bundle: `{bundle_path.name}`",
        f"- Bundle Size Bytes: `{bundle_path.stat().st_size}`",
        f"- Bundle Root Directory: `{root_dir}`",
        f"- Release Version: `{manifest.get('release_version', 'unknown')}`",
        f"- Build Timestamp (UTC): `{manifest.get('build_ts_utc', 'unknown')}`",
        f"- Git Commit: `{manifest.get('git_commit', 'unknown')}`",
        f"- Manifest Bundle Name: `{manifest.get('bundle_name', 'unknown')}`",
        f"- SHA256: `{actual_checksum}`",
        f"- Component Count: `{len(components)}`",
    ]
    if components:
        lines.append("- Components:")
        for component in components:
            lines.append(f"  - `{component}`")
    return "\n".join(lines) + "\n"


def _build_json_payload(
    *,
    bundle_path: Path,
    actual_checksum: str,
    root_dir: str,
    manifest: dict[str, object],
) -> dict[str, object]:
    components = _as_list(manifest.get("components"))
    return {
        "bundle_name": bundle_path.name,
        "bundle_size_bytes": bundle_path.stat().st_size,
        "bundle_root_directory": root_dir,
        "release_version": str(manifest.get("release_version", "unknown")),
        "build_ts_utc": str(manifest.get("build_ts_utc", "unknown")),
        "git_commit": str(manifest.get("git_commit", "unknown")),
        "manifest_bundle_name": str(manifest.get("bundle_name", "unknown")),
        "sha256": actual_checksum,
        "component_count": len(components),
        "components": components,
    }


def main() -> int:
    args = _parse_args()
    bundle_path = Path(args.bundle)
    checksum_path = Path(args.checksum) if args.checksum else Path(f"{bundle_path}.sha256")
    output_path = Path(args.output) if args.output else None
    json_output_path = Path(args.json_output) if args.json_output else None

    if not bundle_path.exists():
        print(f"error: bundle not found: {bundle_path}")
        return 2
    if not checksum_path.exists():
        print(f"error: checksum file not found: {checksum_path}")
        return 2

    try:
        expected_checksum = _read_expected_checksum(checksum_path)
        actual_checksum = _compute_sha256(bundle_path)
        if actual_checksum != expected_checksum:
            raise ValueError(
                f"checksum mismatch: expected={expected_checksum} actual={actual_checksum}"
            )
        root_dir, manifest = _extract_manifest(bundle_path)
    except (ValueError, tarfile.TarError, json.JSONDecodeError) as exc:
        print(f"error: release audit summary generation failed: {exc}")
        return 2

    markdown = _build_markdown(
        bundle_path=bundle_path,
        actual_checksum=actual_checksum,
        root_dir=root_dir,
        manifest=manifest,
    )
    if output_path is not None:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(markdown, encoding="utf-8")
    if json_output_path is not None:
        json_output_path.parent.mkdir(parents=True, exist_ok=True)
        payload = _build_json_payload(
            bundle_path=bundle_path,
            actual_checksum=actual_checksum,
            root_dir=root_dir,
            manifest=manifest,
        )
        json_output_path.write_text(
            json.dumps(payload, ensure_ascii=True, sort_keys=True, indent=2) + "\n",
            encoding="utf-8",
        )
    print(markdown, end="")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
