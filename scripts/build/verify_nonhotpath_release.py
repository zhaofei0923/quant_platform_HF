#!/usr/bin/env python3
from __future__ import annotations

import argparse
import hashlib
import json
import tarfile
from pathlib import Path

_REQUIRED_RELATIVE_PATHS = (
    "deploy/release_manifest.json",
    "docs/SYSTEMD_DEPLOYMENT_RUNBOOK.md",
    "docs/K8S_DEPLOYMENT_RUNBOOK.md",
    "docs/WAL_RECOVERY_RUNBOOK.md",
    "docs/WAL_RECOVERY_RESULT.md",
    "scripts/build/package_nonhotpath_release.sh",
    "scripts/build/release_audit_index.py",
    "scripts/build/release_audit_summary.py",
    "scripts/build/verify_nonhotpath_release.py",
    "scripts/build/verify_release_audit_index.py",
    "scripts/build/verify_release_audit_summary.py",
    "scripts/ops/run_reconnect_evidence.py",
    "scripts/ops/reconnect_slo_report.py",
    "scripts/ops/verify_wal_recovery_evidence.py",
    "configs/sim/ctp.yaml",
    "python/quant_hft/__init__.py",
)


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Verify non-hotpath release bundle integrity: checksum, "
            "manifest contract, and required file set"
        )
    )
    parser.add_argument("--bundle", required=True, help="Path to bundle .tar.gz")
    parser.add_argument(
        "--checksum",
        default="",
        help="Path to sha256 file generated by sha256sum (default: <bundle>.sha256)",
    )
    parser.add_argument(
        "--expect-version",
        default="",
        help="Expected release version in manifest (optional)",
    )
    return parser.parse_args()


def _read_expected_checksum(checksum_path: Path) -> str:
    line = checksum_path.read_text(encoding="utf-8").strip()
    token = line.split()[0] if line else ""
    if len(token) != 64:
        raise ValueError("checksum file missing valid sha256 token")
    return token.lower()


def _compute_sha256(path: Path) -> str:
    sha256 = hashlib.sha256()
    with path.open("rb") as handle:
        while True:
            chunk = handle.read(1024 * 1024)
            if not chunk:
                break
            sha256.update(chunk)
    return sha256.hexdigest()


def _bundle_name_from_path(bundle_path: Path) -> str:
    name = bundle_path.name
    suffix = ".tar.gz"
    if not name.endswith(suffix):
        raise ValueError("bundle must end with .tar.gz")
    return name[: -len(suffix)]


def _first_level_member(member_name: str) -> str:
    return member_name.split("/", 1)[0] if member_name else ""


def _load_manifest(archive: tarfile.TarFile, manifest_member: str) -> dict[str, object]:
    handle = archive.extractfile(manifest_member)
    if handle is None:
        raise ValueError("manifest member is missing or unreadable")
    with handle:
        payload = json.load(handle)
    if not isinstance(payload, dict):
        raise ValueError("manifest must be a JSON object")
    return payload


def _verify_bundle_structure(
    bundle_path: Path,
    *,
    expected_bundle_name: str,
    expected_version: str,
) -> None:
    with tarfile.open(bundle_path, "r:gz") as archive:
        members = archive.getnames()
        if not members:
            raise ValueError("bundle archive is empty")
        roots = {_first_level_member(name) for name in members if name}
        roots.discard("")
        if len(roots) != 1:
            raise ValueError("bundle must contain exactly one top-level directory")

        (root_dir,) = tuple(roots)
        if root_dir != expected_bundle_name:
            raise ValueError(
                f"bundle root mismatch: expected {expected_bundle_name}, got {root_dir}"
            )

        member_set = set(members)
        for relative_path in _REQUIRED_RELATIVE_PATHS:
            target = f"{root_dir}/{relative_path}"
            if target not in member_set:
                raise ValueError(f"required file missing: {relative_path}")

        manifest_member = f"{root_dir}/deploy/release_manifest.json"
        manifest = _load_manifest(archive, manifest_member)
        required_manifest_keys = (
            "release_version",
            "build_ts_utc",
            "git_commit",
            "bundle_name",
            "components",
        )
        for key in required_manifest_keys:
            if key not in manifest:
                raise ValueError(f"manifest missing required key: {key}")

        bundle_name = str(manifest["bundle_name"])
        if bundle_name != root_dir:
            raise ValueError(
                f"manifest bundle_name mismatch: expected {root_dir}, got {bundle_name}"
            )

        manifest_version = str(manifest["release_version"])
        derived_version = root_dir.replace("quant-hft-nonhotpath-", "", 1)
        if manifest_version != derived_version:
            raise ValueError(
                "manifest release_version mismatch with bundle filename "
                f"(manifest={manifest_version}, bundle={derived_version})"
            )

        if expected_version and manifest_version != expected_version:
            raise ValueError(
                "manifest release_version mismatch with expected version "
                f"(manifest={manifest_version}, expected={expected_version})"
            )


def main() -> int:
    args = _parse_args()
    bundle_path = Path(args.bundle)
    checksum_path = Path(args.checksum) if args.checksum else Path(f"{bundle_path}.sha256")
    expect_version = args.expect_version.strip()

    if not bundle_path.exists():
        print(f"error: bundle not found: {bundle_path}")
        return 2
    if not checksum_path.exists():
        print(f"error: checksum file not found: {checksum_path}")
        return 2

    try:
        expected_checksum = _read_expected_checksum(checksum_path)
    except ValueError as exc:
        print(f"error: checksum parse failed: {exc}")
        return 2

    actual_checksum = _compute_sha256(bundle_path)
    if actual_checksum != expected_checksum:
        print(
            "error: checksum mismatch: "
            f"expected={expected_checksum} actual={actual_checksum}"
        )
        return 2

    try:
        expected_bundle_name = _bundle_name_from_path(bundle_path)
        _verify_bundle_structure(
            bundle_path,
            expected_bundle_name=expected_bundle_name,
            expected_version=expect_version,
        )
    except (ValueError, tarfile.TarError, json.JSONDecodeError) as exc:
        print(f"error: release bundle verification failed: {exc}")
        return 2

    print(f"verification passed: {bundle_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
